{"ast":null,"code":"var wgs84 = require('wgs84');\nmodule.exports.geometry = geometry;\nmodule.exports.ring = ringArea;\nfunction geometry(_) {\n  if (_.type === 'Polygon') return polygonArea(_.coordinates);else if (_.type === 'MultiPolygon') {\n    var area = 0;\n    for (var i = 0; i < _.coordinates.length; i++) {\n      area += polygonArea(_.coordinates[i]);\n    }\n    return area;\n  } else {\n    return null;\n  }\n}\nfunction polygonArea(coords) {\n  var area = 0;\n  if (coords && coords.length > 0) {\n    area += Math.abs(ringArea(coords[0]));\n    for (var i = 1; i < coords.length; i++) {\n      area -= Math.abs(ringArea(coords[i]));\n    }\n  }\n  return area;\n}\n\n/**\r\n * Calculate the approximate area of the polygon were it projected onto\r\n *     the earth.  Note that this area will be positive if ring is oriented\r\n *     clockwise, otherwise it will be negative.\r\n *\r\n * Reference:\r\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\r\n *     Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\r\n *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\r\n *\r\n * Returns:\r\n * {float} The approximate signed geodesic area of the polygon in square\r\n *     meters.\r\n */\n\nfunction ringArea(coords) {\n  var area = 0;\n  if (coords.length > 2) {\n    var p1, p2;\n    for (var i = 0; i < coords.length - 1; i++) {\n      p1 = coords[i];\n      p2 = coords[i + 1];\n      area += rad(p2[0] - p1[0]) * (2 + Math.sin(rad(p1[1])) + Math.sin(rad(p2[1])));\n    }\n    area = area * wgs84.RADIUS * wgs84.RADIUS / 2;\n  }\n  return area;\n}\nfunction rad(_) {\n  return _ * Math.PI / 180;\n}","map":{"version":3,"names":["wgs84","require","module","exports","geometry","ring","ringArea","_","type","polygonArea","coordinates","area","i","length","coords","Math","abs","p1","p2","rad","sin","RADIUS","PI"],"sources":["C:/Users/dzoan/OneDrive/Documents/smieciasmieci/node_modules/geojson-area/index.js"],"sourcesContent":["var wgs84 = require('wgs84');\r\n\r\nmodule.exports.geometry = geometry;\r\nmodule.exports.ring = ringArea;\r\n\r\nfunction geometry(_) {\r\n    if (_.type === 'Polygon') return polygonArea(_.coordinates);\r\n    else if (_.type === 'MultiPolygon') {\r\n        var area = 0;\r\n        for (var i = 0; i < _.coordinates.length; i++) {\r\n            area += polygonArea(_.coordinates[i]);\r\n        }\r\n        return area;\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction polygonArea(coords) {\r\n    var area = 0;\r\n    if (coords && coords.length > 0) {\r\n        area += Math.abs(ringArea(coords[0]));\r\n        for (var i = 1; i < coords.length; i++) {\r\n            area -= Math.abs(ringArea(coords[i]));\r\n        }\r\n    }\r\n    return area;\r\n}\r\n\r\n/**\r\n * Calculate the approximate area of the polygon were it projected onto\r\n *     the earth.  Note that this area will be positive if ring is oriented\r\n *     clockwise, otherwise it will be negative.\r\n *\r\n * Reference:\r\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\r\n *     Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\r\n *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\r\n *\r\n * Returns:\r\n * {float} The approximate signed geodesic area of the polygon in square\r\n *     meters.\r\n */\r\n\r\nfunction ringArea(coords) {\r\n    var area = 0;\r\n\r\n    if (coords.length > 2) {\r\n        var p1, p2;\r\n        for (var i = 0; i < coords.length - 1; i++) {\r\n            p1 = coords[i];\r\n            p2 = coords[i + 1];\r\n            area += rad(p2[0] - p1[0]) * (2 + Math.sin(rad(p1[1])) + Math.sin(rad(p2[1])));\r\n        }\r\n\r\n        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;\r\n    }\r\n\r\n    return area;\r\n}\r\n\r\nfunction rad(_) {\r\n    return _ * Math.PI / 180;\r\n}\r\n"],"mappings":"AAAA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAO,CAAC;AAE5BC,MAAM,CAACC,OAAO,CAACC,QAAQ,GAAGA,QAAQ;AAClCF,MAAM,CAACC,OAAO,CAACE,IAAI,GAAGC,QAAQ;AAE9B,SAASF,QAAQA,CAACG,CAAC,EAAE;EACjB,IAAIA,CAAC,CAACC,IAAI,KAAK,SAAS,EAAE,OAAOC,WAAW,CAACF,CAAC,CAACG,WAAW,CAAC,CAAC,KACvD,IAAIH,CAAC,CAACC,IAAI,KAAK,cAAc,EAAE;IAChC,IAAIG,IAAI,GAAG,CAAC;IACZ,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,CAAC,CAACG,WAAW,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;MAC3CD,IAAI,IAAIF,WAAW,CAACF,CAAC,CAACG,WAAW,CAACE,CAAC,CAAC,CAAC;IACzC;IACA,OAAOD,IAAI;EACf,CAAC,MAAM;IACH,OAAO,IAAI;EACf;AACJ;AAEA,SAASF,WAAWA,CAACK,MAAM,EAAE;EACzB,IAAIH,IAAI,GAAG,CAAC;EACZ,IAAIG,MAAM,IAAIA,MAAM,CAACD,MAAM,GAAG,CAAC,EAAE;IAC7BF,IAAI,IAAII,IAAI,CAACC,GAAG,CAACV,QAAQ,CAACQ,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IACrC,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,MAAM,CAACD,MAAM,EAAED,CAAC,EAAE,EAAE;MACpCD,IAAI,IAAII,IAAI,CAACC,GAAG,CAACV,QAAQ,CAACQ,MAAM,CAACF,CAAC,CAAC,CAAC,CAAC;IACzC;EACJ;EACA,OAAOD,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASL,QAAQA,CAACQ,MAAM,EAAE;EACtB,IAAIH,IAAI,GAAG,CAAC;EAEZ,IAAIG,MAAM,CAACD,MAAM,GAAG,CAAC,EAAE;IACnB,IAAII,EAAE,EAAEC,EAAE;IACV,KAAK,IAAIN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,MAAM,CAACD,MAAM,GAAG,CAAC,EAAED,CAAC,EAAE,EAAE;MACxCK,EAAE,GAAGH,MAAM,CAACF,CAAC,CAAC;MACdM,EAAE,GAAGJ,MAAM,CAACF,CAAC,GAAG,CAAC,CAAC;MAClBD,IAAI,IAAIQ,GAAG,CAACD,EAAE,CAAC,CAAC,CAAC,GAAGD,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAGF,IAAI,CAACK,GAAG,CAACD,GAAG,CAACF,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGF,IAAI,CAACK,GAAG,CAACD,GAAG,CAACD,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAClF;IAEAP,IAAI,GAAGA,IAAI,GAAGX,KAAK,CAACqB,MAAM,GAAGrB,KAAK,CAACqB,MAAM,GAAG,CAAC;EACjD;EAEA,OAAOV,IAAI;AACf;AAEA,SAASQ,GAAGA,CAACZ,CAAC,EAAE;EACZ,OAAOA,CAAC,GAAGQ,IAAI,CAACO,EAAE,GAAG,GAAG;AAC5B"},"metadata":{},"sourceType":"script","externalDependencies":[]}